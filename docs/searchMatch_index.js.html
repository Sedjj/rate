<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: searchMatch/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: searchMatch/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const log = require('./../utils/logger');
const {CronJob} = require('cron');
const {newField, setField} = require('./../storage');
const {getFootball, getFootballExpanded, postResult} = require('./../fetch');
const config = require('config');
const {sendMessage} = require('./../telegramApi');

const before = config.get('choice.live.football.time.before');
const after = config.get('choice.live.football.time.after');
const rateStrategyOne = config.get('choice.live.football.strategyOne.rate');
const rateStrategyTwo = config.get('choice.live.football.strategyTwo.rate');
const totalStrategy = config.get('choice.live.football.total');
/*const score = config.get('choice.live.football.score');*/
const numericalDesignation = config.get('choice.live.football.numericalDesignation');
const waitingInterval = process.env.NODE_ENV === 'development'
	? '* /02 * * * *'
	: config.get('cron.waitingInterval');

/**
 * метод поиска совпадений по данным стратегиям.
 *
 * @returns {*}
 */
function search() {
	getFootball()
		.then((item) => {
			item.map((item) => {
				footballLiveStrategy(item);
			});
		})
		.catch(error => {
			log.error('error search: ', error);
		});
}

/**
 * Общая стратегия для Live футбола
 *
 * @param {Array} item массив ставок
 */
function footballLiveStrategy(item) {
	if (item.SC &amp;&amp; item.SC.FS &amp;&amp; item.E &amp;&amp; item.SC.TS) {
		const score = scoreGame(item);
		const tm = timeGame(item);// проверяем время матча
		if (Array.isArray(item.E)) {
			const index = indexGame(item);
			if ((item.O1.indexOf('(') === -1) &amp;&amp; (item.O2.indexOf('(') === -1) &amp;&amp; (item.O1.indexOf('II') === -1) &amp;&amp; (item.O2.indexOf('II') === -1)) {
				if ((index.p1 !== '') &amp;&amp; (index.p2 !== '') &amp;&amp; (index.x !== '')) {
					if ((tm >= before) &amp;&amp; (tm >= after)) {
						if (score.sc1 === score.sc2) {
							footballLiveStrategyOne(item, index);
						} else if (score.sc1 + score.sc2 === score) {
							footballLiveStrategyTwo(item, index);
						}
					}
				}
			}
		}
	}
}

/**
 * Стратегия гол лузера
 *
 * @param {Array} item массив ставок
 * @param {Number} index ставки
 */
async function footballLiveStrategyOne(item, index) {
	if ((Math.abs(index.p1 - index.p2) &lt;= rateStrategyOne)) {
		try {
			const oldScore = scoreGame(item);
			await saveRate(item, '1');
			const total = await waiting(item, '1', oldScore);
			if (total !== -1) { // -1 - это время истекло или поменялся счет
				const endScore = await waitingEndMatch(item, '1');
				const result = equalsTotal(oldScore, parserScore(endScore));
				if (result === 0 || result === 1) {
					setRate(item.I, result);
				}
			}
		} catch (error) {
			log.error('footballLiveStrategyOne error: ', error);
		}
	}
}

/**
 * Стратегия ничья с явным фаворитом
 *
 * @param {Array} item массив ставок
 * @param {Number} index ставки
 */
async function footballLiveStrategyTwo(item, index) {
	if ((Math.abs(index.p1 - index.p2) &lt;= rateStrategyTwo)) {
		if (index.x > Math.min(index.p1, index.p2)) {
			try {
				const oldScore = scoreGame(item);
				await saveRate(item, '2');
				const total = await waiting(item, '2', oldScore);
				if (total !== -1) { // -1 - это время истекло или поменялся счет
					const endScore = await waitingEndMatch(item, '2');
					const result = equalsTotal(oldScore, parserScore(endScore));
					if (result === 0 || result === 1) {
						setRate(item.I, result);
					}
				}
			} catch (error) {
				log.error('footballLiveStrategyTwo error: ', error);
			}
		}
	}
}

/**
 * Метод для мониторинга Total.
 *
 * @param {Array} item массив ставок
 * @param {string} strategy стратегия
 * @param {Object} oldScore старый счет матча
 * @returns {Promise&lt;Number>}
 */
function waiting(item, strategy, oldScore) {
	let waitingIntervalJob;
	return new Promise((resolve, reject) => {
		try {
			waitingIntervalJob = new CronJob(waitingInterval, async () => {
				const indexMatch = await searchIndex(item.I, strategy, oldScore);
				if (indexMatch !== null) {
					waitingIntervalJob.stop();
					resolve(indexMatch);
				}
			}, null, true);
		} catch (error) {
			waitingIntervalJob.stop();
			log.error('cron waiting error: ', error);
			reject(ex);
		}
	});
}

/**
 * сохраняем матч и проверяем ставки
 *
 * находим ставку с определенным Total = (sc1+sc1+1)
 * если нет Total -> крон на ожидание 2 мин
 *
 * если есть Total - то сравниваем с 1,3 для первой и 1,5 для второй иначе снова ждем
 *
 * если счет изменился то выходим и в бд пишем 1 и не отслеживаем конец матча
 *
 * @param {number} id матча
 * @param {string} strategy стратегия
 * @param {Object} oldScore старый счет матча
 */
function searchIndex(id, strategy, oldScore) {
	return getFootballExpanded(id)
		.then((item) => {
			let index = null;
			const score = scoreGame(item); // счета матча
			const tm = timeGame(item); // проверяем время матча
			if (Object.is(JSON.stringify(oldScore), JSON.stringify(score)) &amp;&amp; tm &lt;= 4320) {
				if (item.GE &amp;&amp; Array.isArray(item.GE)) {
					item.GE.map((rate) => {
						if (rate.G === '17') { // 17 - тотал
							const total = score.sc1 + score.sc2 + 1;
							if (item.E &amp;&amp; Array.isArray(item.E[0])) {
								rate.E[0].map((item) => { // 0 - так как столбец "больше"
									if (item.P === total) {
										if (item.C > totalStrategy[strategy]) {
											setRate(id, index = item.C);
										}
									}
								}).catch(error => {
									log.error('error searchIndex E: ', error);
								});
							}
						}
					}).catch(error => {
						log.error('error searchIndex GE: ', error);
					});
				}
			} else {
				return -1;
			}
			return index;
		})
		.catch(error => {
			log.error('error getFootballExpanded: ', error);
		});
}

/**
 * Метод для ожидания окончания матча.
 *
 * если нашли нужный то ждем окончания матча 120 мин
 *
 * @param {Array} item массив ставок
 * @returns {Promise&lt;Number>}
 */
function waitingEndMatch(item) {
	const endGame = (7200 - timeGame(item)) * 1000;
	return new Promise((resolve, reject) => {
		try {
			setTimeout(async () => {
				resolve(await serchResult(numericalDesignation, item.I));
			}, endGame);
		} catch (error) {
			log.error('waitingEndMatch error: ', error);
			reject(ex);
		}
	});
}

/**
 * Метод для поиска результата матча.
 *
 * @param {number} type соревнования(1 - футбол)
 * @param {number} id матча
 * @returns {Promise&lt;void>}
 */
async function serchResult(type, id) {
	let score = null;
	try {
		const data = await postResult();
		data.forEach((item) => {
			if (item.ID === type) {
				item.Elems.map((object) => {
					if (Array.isArray(object.Elems)) {
						if (object.Elems[0].Head[0] === id) {
							score = object.Elems[0].Head[6];
						}
					}
				});
			}
		});
		
	} catch (error) {
		log.error('serchResult error: ', error);
	}
	return score;
}

/**
 * Метод для определения счета матча.
 *
 * @param {Object} item объект матча
 * @returns {{sc1: number, sc2: number}}
 */
function scoreGame(item) {
	return {
		sc1: item.SC.FS.S1 ? item.SC.FS.S1 : 0, // проверяем счет матча
		sc2: item.SC.FS.S2 ? item.SC.FS.S2 : 0 // проверяем счет матча
	};
}

/**
 * Метод для определения ставок матча.
 *
 * @param {Object} item объект матча
 * @returns {{sc1: number, sc2: number}}
 */
function indexGame(item) {
	return {
		p1: item.E[0] ? item.E[0].C : '', // попеда первой
		x: item.E[1] ? item.E[1].C : '', // ничья
		p2: item.E[2] ? item.E[2].C : '' // поведа второй
	};
}

/**
 * Метод для определения времени матча.
 *
 * @param {Object} item объект матча
 * @returns {{sc1: number, sc2: number}}
 */
function timeGame(item) {
	return item.SC.TS ? Math.floor(item.SC.TS / 60) : 0;
}

/**
 * Cравниваем Total 2-x таймов не изменился ли.
 * Eсли изменился то меняем даные в таблице .
 * {
 * 		x = исходного -> 1
 * 		x &lt; исходного -> 0
 * 		x > исходного -> ставка
 * }
 * @param {Object} oldScore исходные данные Total
 * @param {Object} endTotal результирующие данные Total
 */
function equalsTotal(oldScore, endScore) {
	const start = oldScore.sc1 + oldScore.sc2;
	const end = endScore.sc1 + endScore.sc2;
	if (start === end) {
		return 1;
	} else if (start > end) {
		return 0;
	}
}

/**
 * Метод для нахождения общего счета за 2 тайма
 *
 * @param {String} value строка для парсинга
 * @returns {Object}
 */
function parserScore(value) {
	const score = value.match('/\\d\\:\\d(?=,|\\))/g');
	const scoreOne = score[0].match('/\\d/g');
	const scoreTwo = score[1].match('/\\d/g');
	return {
		sc1: scoreOne[0] + scoreOne[1],
		sc2: scoreTwo[0] + scoreTwo[1]
	};
}

/**
 * Метод для изменения ставки.
 *
 * @param {Number} id матча
 * @param {Number} index коэфф
 */
function setRate(id = 0, index = 1) {
	return setField({
		matchId: id,
		index: index
	});
}

/**
 * Метод для создании записи в бд.
 *
 * @param {Object} item объект матча
 * @param {String} strategy стратегия ставок
 */
function saveRate(item = {}, strategy) {
	sendMessage('id:' + item.I + ' ' + 'O1:' + item.O1 + ' ' + 'O2:' + item.O2 + ' ' + 'strategy:' + strategy);
	return newField({
		matchId: item.I, // id матча
		commandOne: item.O1, // название команды 1
		commandTwo: item.O2, // название команды 2
		strategy: strategy, // стратегия
		index: '1' // коэфф.
	});
}

module.exports = {
	search
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#decorateMessage">decorateMessage</a></li><li><a href="global.html#equalsTotal">equalsTotal</a></li><li><a href="global.html#footballLiveStrategy">footballLiveStrategy</a></li><li><a href="global.html#footballLiveStrategyOne">footballLiveStrategyOne</a></li><li><a href="global.html#footballLiveStrategyTwo">footballLiveStrategyTwo</a></li><li><a href="global.html#getFields">getFields</a></li><li><a href="global.html#getFootball">getFootball</a></li><li><a href="global.html#getFootballExpanded">getFootballExpanded</a></li><li><a href="global.html#getFormattedDate">getFormattedDate</a></li><li><a href="global.html#getFormattedTime">getFormattedTime</a></li><li><a href="global.html#getTime">getTime</a></li><li><a href="global.html#indexGame">indexGame</a></li><li><a href="global.html#logger">logger</a></li><li><a href="global.html#mapProps">mapProps</a></li><li><a href="global.html#newField">newField</a></li><li><a href="global.html#parserScore">parserScore</a></li><li><a href="global.html#postResult">postResult</a></li><li><a href="global.html#replaceAll">replaceAll</a></li><li><a href="global.html#saveRate">saveRate</a></li><li><a href="global.html#scoreGame">scoreGame</a></li><li><a href="global.html#search">search</a></li><li><a href="global.html#searchIndex">searchIndex</a></li><li><a href="global.html#sendMessage">sendMessage</a></li><li><a href="global.html#serchResult">serchResult</a></li><li><a href="global.html#setField">setField</a></li><li><a href="global.html#setRate">setRate</a></li><li><a href="global.html#timeGame">timeGame</a></li><li><a href="global.html#waiting">waiting</a></li><li><a href="global.html#waitingEndMatch">waitingEndMatch</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Oct 17 2018 22:59:15 GMT+0500 (GMT+05:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
